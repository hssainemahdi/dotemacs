* Detect system type
#+BEGIN_SRC emacs-lisp
(defconst sys/win32p
  (eq system-type 'windows-nt)
  "Are we running on a WinTel system?")
#+END_SRC

* Package installation
** Refresh package list
#+BEGIN_SRC emacs-lisp
(when (not package-archive-contents)
  (package-refresh-contents))
#+END_SRC
** Packages to retrieve from repo
#+BEGIN_SRC emacs-lisp
(defvar myPackages
  '(better-defaults
    flycheck ; syntax/grammar checker
    py-autopep8 ; allow autopep 8 reformating upon save
#+END_SRC
*** Ansible
#+BEGIN_SRC emacs-lisp
ansible
ansible-doc
ansible-vault
#+END_SRC
*** Misc
#+BEGIN_SRC emacs-lisp
0blayout ; window layout
ac-etags
ac-html
ac-html-csswatcher
ac-php
ace-window
all-the-icons
anzu ; display search number of matching occurences
desktop+
dtrt-indent
doom-modeline
emojify ; display emojis
fill-column-indicator
fontawesome
ggtags
git-gutter
git-messenger
helm
helm-swoop
ido
lv
magit ; git support
magit-gitflow
org-bullets
paradox ; better melpa browsing
phpunit
projectile
rainbow-delimiters ; matching parentheses colorization
sphinx-doc
treemacs
treemacs-projectile
use-package
use-package-ensure-system-package
which-key
ztree ; Directory tree diff
#+END_SRC
*** Themes
#+BEGIN_SRC emacs-lisp
badger-theme
zerodark-theme
monokai-theme
material-theme
zenburn-theme
gruvbox-theme
doom-themes
doom-modeline
spacemacs-theme
atom-one-dark-theme
#+END_SRC
*** Modes
#+BEGIN_SRC emacs-lisp
;;markdown-preview-mode
anaconda-mode
angular-mode
apache-mode
csv-mode
demangle-mode
docker
dotenv-mode
elpy ; python tool
groovy-mode
jinja2-mode
markdown-mode
nasm-mode
nginx-mode
npm-mode
php-mode
rainbow-mode
yaml-mode
))
#+END_SRC
** Actual installation
#+BEGIN_SRC emacs-lisp
(mapc #'(lambda (package)
	  (unless (package-installed-p package)
	    (package-install package)))
      myPackages)
#+END_SRC

* Themes
** Create themes directory
#+BEGIN_SRC emacs-lisp
;; Don't miss the trailing "/"
(setq my-themes-dir "~/.emacs.d/themes/")
(unless (file-directory-p my-themes-dir)
  (dired-create-directory my-themes-dir))
#+END_SRC

** Additional themes from github
#+BEGIN_SRC emacs-lisp
(defun clone-theme(git-url dst-dir-name)
  (shell-command
   (concat "git clone " git-url " " my-themes-dir dst-dir-name " 2> /dev/null || true")))

(let ((github-themes-url
       '(
	 ("https://github.com/ianpan870102/Emacs-Tron-Legacy-Theme" . "Emacs-Tron-Legacy-Theme")
	 )))

  (mapcar (lambda (element)
	    (let ((url (car element))
		  (dest (cdr element)))
	      (unless (file-directory-p dest)
		(clone-theme url dest)))
	    ) github-themes-url))
#+END_SRC

** Add all themes under ~/.emacs.d/themes directory to load-path
#+BEGIN_SRC emacs-lisp
(when (file-directory-p my-themes-dir)
  (dolist (f (directory-files my-themes-dir))
    (if (and (not (or (equal f ".") (equal f "..")))
             (file-directory-p (concat my-themes-dir f)))
        (add-to-list 'custom-theme-load-path (concat my-themes-dir f)))))

#+END_SRC
*** Github theme
#+BEGIN_SRC emacs-lisp
(use-package github-theme
  :ensure t
  :defer t
  )
#+END_SRC

*** Kaolin themes
#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes
  :ensure t
  :defer t
  )
#+END_SRC

** Load themes
***
This package advises the `enable-theme' function and convert non-terminal colors to their closest approximation. Inspired by VIM's CSApprox plugin
http://www.vim.org/scripts/script.php?script_id=2390

Normally Emacs does have non-terminal color themes degrade, however in some system the effect is pretty poor. I've encountered this on Arch Linux and Ubuntu (probably caused by some libvte weirdness).
#+BEGIN_SRC emacs-lisp
(use-package color-theme-approximate
  :ensure t
  :if (not (window-system))
  :init
  (autoload 'color-theme-approximate-on "color-theme-approximate")
  (color-theme-approximate-on)
  )
#+END_SRC
*** Disable active theme when loading a new one

See https://www.simplify.ba/articles/2016/02/13/loading-and-unloading-emacs-themes/

#+BEGIN_SRC emacs-lisp
(defun load-theme--disable-old-theme(theme &rest args)
  "Disable current theme before loading new one."
  (mapcar #'disable-theme custom-enabled-themes))
(advice-add 'load-theme :before #'load-theme--disable-old-theme)
#+END_SRC

Load different themes for console and graphic mode
#+BEGIN_SRC emacs-lisp
(load-theme 'doom-acario-dark t)
#+END_SRC

* Buffer/Window helpers
** Kill buffer using f9
#+BEGIN_SRC emacs-lisp
(global-set-key [f9] 'kill-this-buffer)
#+END_SRC
** Window resize shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "S-C-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "S-C-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "S-C-<down>") 'shrink-window)
(global-set-key (kbd "S-C-<up>") 'enlarge-window)
#+END_SRC
** Balanced windows
#+BEGIN_SRC emacs-lisp
(use-package balanced-windows
  :ensure t
  :config
  (balanced-windows-mode)
)
#+END_SRC
** Window move
#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings 'meta)
(when (fboundp 'windmove-default-keybindings)
  (windmove-default-keybindings))
#+END_SRC
** Temporary buffer full screen with Ctrl + f11
#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-buffer () "Maximize buffer"
       (interactive)
       (if (= 1 (length (window-list)))
           (jump-to-register '_)
         (progn
           (window-configuration-to-register '_)
           (delete-other-windows))))
(global-set-key [(ctrl f11)] 'toggle-maximize-buffer)
#+END_SRC
** Transparency
#+BEGIN_SRC emacs-lisp
;; https://www.emacswiki.org/emacs/TransparentEmacs
(defun toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter nil 'alpha
			 (if (eql (cond ((numberp alpha) alpha)
					((numberp (cdr alpha)) (cdr alpha))
					;; Also handle undocumented (<active> <inactive>) form.
					((numberp (cadr alpha)) (cadr alpha)))
				  100)
			     '(90 . 90) '(100 . 100))))) ;;active/inactive frame transparency
(global-set-key (kbd "C-c T") 'toggle-transparency)

;; Set transparency of emacs
(defun transparency (value)
  "Sets the transparency of the frame window. 0=transparent/100=opaque"
  (interactive "nTransparency Value 0 - 100 opaque:")
  (set-frame-parameter (selected-frame) 'alpha value))
#+END_SRC
** Font size
To use: M-x x-setface-height RET 100 RET
#+BEGIN_SRC emacs-lisp
(defun x-setface-height (number)
  "Face height is set to NUMBER."
  (interactive "nInsert number: ")
  (set-face-attribute 'default (selected-frame) :height number))

(global-set-key (kbd "C-c o") (lambda() (interactive) (x-setface-height 80)))
(global-set-key (kbd "C-c O") (lambda() (interactive) (x-setface-height 100)))

#+END_SRC
** Ace window
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :init
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  :bind ("M-o" . ace-window)
)

#+END_SRC
** Mouse & Smooth Scroll
#+BEGIN_SRC emacs-lisp
;; Scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
(setq mouse-wheel-progressive-speed nil)
(setq scroll-step 1
      scroll-margin 0
      scroll-conservatively 100000)
#+END_SRC
** Display time
#+BEGIN_SRC emacs-lisp
;; Display Time
(use-package time
  :ensure nil
  :unless (display-graphic-p)
  :hook (after-init . display-time-mode)
  :init
  (setq display-time-24hr-format t)
  (setq display-time-day-and-date t))
#+END_SRC

** Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil)
(setq use-dialog-box nil)
(setq inhibit-startup-screen t)
#+END_SRC

** Visible bell
#+BEGIN_SRC emacs-lisp
(setq visible-bell t)
#+END_SRC

** Size indication mode
#+BEGIN_SRC emacs-lisp
(size-indication-mode 1)
#+END_SRC

** Blink cursor
#+BEGIN_SRC emacs-lisp
;; (blink-cursor-mode -1)
#+END_SRC

** Track EOL
#+BEGIN_SRC emacs-lisp
(setq line-move-visual nil)
(setq track-eol t)                      ; Keep cursor at end of lines. Require line-move-visual is nil.
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq inhibit-compacting-font-caches t) ; Don’t compact font caches during GC.

;; Don't open a file in a new frame
(when (boundp 'ns-pop-up-frames)
(setq ns-pop-up-frames nil))

;; Don't use GTK+ tooltip
(when (boundp 'x-gtk-use-system-tooltips)
(setq x-gtk-use-system-tooltips nil))
#+END_SRC

** Basic Interface Settings
These are setting that do not depend on packages and are built-in enhancements to the UI.

***** Looks
******* Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to =dashboard=.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
******* Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
;; Scroll bar mode is not defined depending on emacs build option
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
#+END_SRC
******* Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
******* Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC
******* Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
(when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC
******* Pretty symbols
Changes =lambda= to an actual symbol and a few others as well, only in the GUI version though.
#+BEGIN_SRC emacs-lisp
(when window-system
  (use-package pretty-mode
    :ensure t
    :config
    (global-pretty-mode t)))
#+END_SRC

***** Functionality
****** Disable backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC

****** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

****** Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
(use-package async
  :ensure t
  :init (dired-async-mode 1))
#+END_SRC

***** Programming
****** Package manager
- =clang=, for c/c++ completion.
- =sbcl=, for clisp completion and repl.
- =virtualenv=, for python completion.
- =lua=, for obvious reasons.

****** pip
- =pip install jedi flake8 autopep8=, here, a one line install.

** Treemacs
#+BEGIN_SRC emacs-lisp
(use-package treemacs
  :ensure t
  :defer t
  :init
  (with-eval-after-load 'winum
    (define-key winum-keymap (kbd "C-c t s") #'treemacs-select-window))
  :config
  (progn
    (setq treemacs-collapse-dirs                 (if (executable-find "python3") 3 0)
          treemacs-deferred-git-apply-delay      0.5
          treemacs-display-in-side-window        t
          treemacs-eldoc-display                 t
          treemacs-file-event-delay              5000
          treemacs-file-follow-delay             0.2
          treemacs-follow-after-init             t
          treemacs-git-command-pipe              ""
          treemacs-goto-tag-strategy             'refetch-index
          treemacs-indentation                   2
          treemacs-indentation-string            " "
          treemacs-is-never-other-window         nil
          treemacs-max-git-entries               5000
          treemacs-missing-project-action        'ask
          treemacs-no-png-images                 nil
          treemacs-no-delete-other-windows       t
          treemacs-project-follow-cleanup        nil
          treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
          treemacs-recenter-distance             0.1
          treemacs-recenter-after-file-follow    nil
          treemacs-recenter-after-tag-follow     nil
          treemacs-recenter-after-project-jump   'always
          treemacs-recenter-after-project-expand 'on-distance
          treemacs-show-cursor                   nil
          treemacs-show-hidden-files             t
          treemacs-silent-filewatch              nil
          treemacs-silent-refresh                nil
          treemacs-sorting                       'alphabetic-desc
          treemacs-space-between-root-nodes      t
          treemacs-tag-follow-cleanup            t
          treemacs-tag-follow-delay              1.5
          treemacs-width                         35)

    ;; The default width and height of the icons is 22 pixels. If you are
    ;; using a Hi-DPI display, uncomment this to double the icon size.
    ;;(treemacs-resize-icons 44)

    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode t)
    (pcase (cons (not (null (executable-find "git")))
                 (not (null (executable-find "python3"))))
      (`(t . t)
       (treemacs-git-mode 'deferred))
      (`(t . _)
       (treemacs-git-mode 'simple))))
  :bind
  (:map global-map
        ("C-x t s"   . treemacs-select-window)
        ("C-x t 1"   . treemacs-delete-other-windows)
        ("C-x t t"   . treemacs)
        ("C-x t B"   . treemacs-bookmark)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag))
  )

(use-package treemacs-icons-dired
  :after treemacs dired
  :ensure t
  :config (treemacs-icons-dired-mode))

(use-package treemacs-magit
  :after treemacs magit
  :ensure t)

(use-package treemacs-projectile
  :after treemacs magit
  :ensure t
  )

#+END_SRC
* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :init
  (projectile-mode 1)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  :config
  (setq projectile-completion-system 'helm
        projectile-switch-project-action 'helm-projectile)
  )
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
;; (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.
#+BEGIN_SRC emacs-lisp
(use-package dashboard
  :ensure t
  :config
  (dashboard-setup-startup-hook)
  ;; (setq dashboard-startup-banner "~/.emacs.d/img/apero.png")
  (setq dashboard-items '((recents  . 5)
                          (projects . 5)))
  (setq dashboard-banner-logo-title "")
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
)
#+END_SRC

* Modeline
#+BEGIN_SRC emacs-lisp
(use-package mood-line
  :ensure t
  :init
  (mood-line-mode)
  )
#+END_SRC

*** No separator!
#+BEGIN_SRC emacs-lisp
(setq powerline-default-separator nil)
#+END_SRC

*** Cursor position
Show the current line and column for your cursor.
We are not going to have =relative-linum-mode= in every major mode, so this is useful.
#+BEGIN_SRC emacs-lisp
(setq line-number-mode t)
(setq column-number-mode t)
#+END_SRC

*** Clock
If you prefer the 12hr-format, change the variable to =nil= instead of =t=.

**** Time format
#+BEGIN_SRC emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

**** Enabling the mode
This turns on the clock globally.
#+BEGIN_SRC emacs-lisp
(display-time-mode 1)
#+END_SRC

*** Battery indicator
A package called =fancy-battery= will be used if we are in GUI emacs, otherwise the built in battery-mode will be used.
Fancy battery has very odd colors if used in the tty, hence us disabling it.
#+BEGIN_SRC emacs-lisp
(use-package fancy-battery
  :ensure t
  :config
  (setq fancy-battery-show-percentage t)
  (setq battery-update-interval 15)
  (if window-system
      (fancy-battery-mode)
    (display-battery-mode)))
#+END_SRC

*** System monitor
A teeny-tiny system monitor that can be enabled or disabled at runtime, useful for checking performance
with power-hungry processes in ansi-term

symon can be toggled on and off with =Super + h=.
#+BEGIN_SRC emacs-lisp
(use-package symon
  :ensure t
  :bind
  ("s-h" . symon-mode))
#+END_SRC

* The terminal
I have used urxvt for years, and I miss it sometimes, but ansi-term is enough for most of my tasks.

** Default shell should be bash
I don't know why this is a thing, but asking me what shell to launch every single
time I open a terminal makes me want to slap babies, this gets rid of it.
This goes without saying but you can replace bash with your shell of choice.
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/usr/bin/zsh")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC

** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

** Shell-pop
#+BEGIN_SRC emacs-lisp
;; Shell Pop
(use-package shell-pop
  :ensure t
  :bind ([f12] . shell-pop)
  :init (let ((val
               (if sys/win32p
                   '("eshell" "*eshell*" (lambda () (eshell)))
                 '("ansi-term" "*ansi-term*"
                   (lambda () (ansi-term shell-pop-term-shell))))))
          (setq shell-pop-shell-type val)
          (setq shell-pop-full-span 1)))
#+END_SRC
* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

As a great emacs user once said:

#+BEGIN_QUOTE
Do me the favor, do me the biggest favor, matter of fact do yourself the biggest favor and integrate those into your workflow.
#+END_QUOTE

** a prerequisite for others packages
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t)
#+END_SRC

** scrolling and why does the screen move
I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
#+END_SRC

** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC

** windows, panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware
you probably use more than 2 panes/windows at times, cycling through all of them with
=C-c o= is annoying to say the least, it's a lot of keystrokes and takes time, time you could spend doing something more productive.

*** switch-window
This magnificent package takes care of this issue.
It's unnoticeable if you have <3 panes open, but with 3 or more, upon pressing =C-x o=
you will notice how your buffers turn a solid color and each buffer is asigned a letter
(the list below shows the letters, you can modify them to suit your liking), upon pressing
a letter asigned to a window, your will be taken to said window, easy to remember, quick to use
and most importantly, it annihilates a big issue I had with emacs. An alternative is =ace-window=,
however by default it also changes the behaviour of =C-x o= even if only 2 windows are open,
this is bad, it also works less well with =exwm= for some reason.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
  (setq switch-window-input-style 'minibuffer)
  (setq switch-window-increase 4)
  (setq switch-window-threshold 2)
  (setq switch-window-shortcut-style 'qwerty)
  (setq switch-window-qwerty-shortcuts
        '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
  (setq switch-window-auto-resize-window nil)
  :bind
  ([remap other-window] . switch-window))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
** prevent emacs from splitting windows
 #+BEGIN_SRC emacs-lisp
(setq split-window-preferred-function (lambda nil (nil)))
 #+END_SRC

** swiper and why is the default search so lame
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn't hurt to search for entire words or mode, swiper makes sure this is more efficient.
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :ensure t
  :bind (("C-s" . 'swiper)
         :map swiper-map
         ("M-%" . swiper-query-replace))
  :config
  (setq swiper-action-recenter t)
)
#+END_SRC

** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.

*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kills the current buffer."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

**** expert-mode
If you feel like you know how ibuffer works and need not to be asked for confirmation after every serious command, enable this as follows.
#+BEGIN_SRC emacs-lisp
(setq ibuffer-expert t)
#+END_SRC
*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
(defun close-all-buffers ()
  "Kill all buffers without regard for their origin."
  (interactive)
  (mapc 'kill-buffer (buffer-list)))
(global-set-key (kbd "C-M-k") 'close-all-buffers)
#+END_SRC

** line numbers and programming
Every now and then all of us feel the urge to be productive and write some code.
In the event that this happens, the following bit of configuration makes sure that
we have access to relative line numbering in programming-related modes.
I highly recommend not enabling =linum-relative-mode= globally, as it messed up
something like =ansi-term= for instance.
#+BEGIN_SRC emacs-lisp
;; (use-package linum-relative
;;   :ensure t
;;   :config
;;     (setq linum-relative-current-symbol "")
;; (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

** ido and why I started using helm
Sometimes, you don't realize how good something is until you try it extensively.
I give in, helm is awesome. I'll end up customizing it more eventually,
it's rather similar to ido-vertical though.
*** helm
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :bind
  ("C-x C-f" . 'helm-find-files)
  ("C-x C-b" . 'helm-buffers-list)
  ("M-x" . 'helm-M-x)
  ("C-c M-y" . 'helm-show-kill-ring)
  :config
  (defun daedreth/helm-hide-minibuffer ()
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))
  (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
  (setq helm-autoresize-max-height 0
        helm-autoresize-min-height 40
        helm-M-x-fuzzy-match t
        helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match t
        helm-semantic-fuzzy-match t
        helm-imenu-fuzzy-match t
        helm-split-window-in-side-p t
        helm-move-to-line-cycle-in-source nil
        helm-ff-search-library-in-sexp t
        helm-scroll-amount 8
        helm-echo-input-in-header-line t)
  :init
  (helm-mode 1))

(require 'helm-config)
(helm-autoresize-mode 1)

#+END_SRC
*** helm-projectile
#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t
  :after 'projectile
  :config
  (helm-projectile-on)
  )
#+END_SRC

** avy and why it's the best thing in existence
Many times have I pondered how I can move around buffers even quicker.
I'm glad to say, that avy is precisely what I needed, and it's precisely what you need as well.
In short, as you invoke one of avy's functions, you will be prompted for a character
that you'd like to jump to in the /visible portion of the current buffer/.
Afterwards you will notice how all instances of said character have additional letter on top of them.
Pressing those letters, that are next to your desired character will move your cursor over there.
Admittedly, this sounds overly complicated and complex, but in reality takes a split second
and improves your life tremendously.

I like =M-s= for it, same as =C-s= is for moving by searching string, now =M-s= is moving by searching characters.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind
  ("M-s" . avy-goto-char))
#+END_SRC

* Text manipulation
Here I shall collect self-made functions that make editing text easier.

** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!
#+BEGIN_SRC emacs-lisp
(use-package mark-multiple
  :ensure t
  :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC

** Improved kill-word
Why on earth does a function called =kill-word= not .. kill a word.
It instead deletes characters from your cursors position to the end of the word,
let's make a quick fix and bind it properly.
#+BEGIN_SRC emacs-lisp
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)
#+END_SRC

** Improved copy-word
And again, the same as above but we make sure to not delete the source word.
#+BEGIN_SRC emacs-lisp
(defun daedreth/copy-whole-word ()
  (interactive)
  (save-excursion
    (forward-char 1)
    (backward-word)
    (kill-word 1)
    (yank)))
(global-set-key (kbd "C-c w c") 'daedreth/copy-whole-word)
#+END_SRC

** Copy a line
Regardless of where your cursor is, this quickly copies a line.
#+BEGIN_SRC emacs-lisp
(defun daedreth/copy-whole-line ()
  "Copies a line without regard for cursor position."
  (interactive)
  (save-excursion
    (kill-new
     (buffer-substring
      (point-at-bol)
      (point-at-eol)))))
(global-set-key (kbd "C-c l c") 'daedreth/copy-whole-line)
#+END_SRC

** Kill a line
And this quickly deletes a line.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC

* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak.
This can be best achieved using a number of small extensions. While on their own they might not be particularly impressive.
Together they create a nice environment for you to work in.

** Visiting the configuration
Quickly edit =~/.emacs.d/settings.org=
#+BEGIN_SRC emacs-lisp
(defun config-visit ()
  (interactive)
  (find-file "~/.emacs.d/settings.org"))
(global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration

Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
(defun config-reload ()
  "Reloads ~/.emacs.d/config.org at runtime"
  (interactive)
  (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
(global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC


** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
#+BEGIN_SRC emacs-lisp
(global-subword-mode 1)
#+END_SRC

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                            (?\{ . ?\})
                            (?\( . ?\))
                            (?\[ . ?\])
                            (?\" . ?\")
                            ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
  (beacon-mode 1))
#+END_SRC

** Rainbow
Mostly useful if you are into web development or game development.
Every time emacs encounters a hexadecimal code that resembles a color, it will automatically highlight
it in the appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :ensure t
  :init
  (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-q" . er/expand-region))
#+END_SRC

** Smart Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.
You may not like it, thus disable it if you must, but it's pretty decent.
#+BEGIN_SRC emacs-lisp
(use-package smart-hungry-delete        ;
  :ensure t
  :bind (("<DEL>" . smart-hungry-delete-backward-char)
         ("C-d" . smart-hungry-delete-forward-char)
         ("<backspace>" . smart-hungry-delete-backward-char)
         )
  :defer nil ;; dont defer so we can add our functions to hooks
  :config (smart-hungry-delete-add-default-hooks)
  )
#+END_SRC

** Zapping to char
A nifty little package that kills all text between your cursor and a selected character.
A lot more useful than you might think. If you wish to include the selected character in the killed region,
change =zzz-up-to-char= into =zzz-to-char=.
#+BEGIN_SRC emacs-lisp
(use-package zzz-to-char
  :ensure t
  :bind ("M-z" . zzz-up-to-char))
#+END_SRC

* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.

CANNOT BROWSE KILL RING INSIDE TERMINAL

#+BEGIN_SRC emacs-lisp
(use-package popup-kill-ring
  :if window-system
  :ensure t
  :bind ("M-y" . popup-kill-ring))
#+END_SRC

* Programming
Minor, non-completion related settings and plugins for writing code.

** yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :hook (after-init . yas-global-mode)
  :config (use-package yasnippet-snippets
            :ensure t)
  (yas-reload-all))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC

** company mode
I set the delay for company mode to kick in immediately, I also make sure that
it starts doing its magic after typing in only 0 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (setq company-idle-delay 0)
  (setq company-minimum-prefix-length 0))

(with-eval-after-load 'company
  (define-key company-active-map (kbd "M-n") nil)
  (define-key company-active-map (kbd "M-p") nil)
  (define-key company-active-map (kbd "C-n") #'company-select-next)
  (define-key company-active-map (kbd "C-p") #'company-select-previous))

  ;;; Prevent suggestions from being triggered automatically. In particular,
  ;;; this makes it so that:
  ;;; - TAB will always complete the current selection.
  ;;; - RET will only complete the current selection if the user has explicitly
  ;;;   interacted with Company.
  ;;; - SPC will never complete the current selection.
  ;;;
  ;;; Based on:
  ;;; - https://github.com/company-mode/company-mode/issues/530#issuecomment-226566961
  ;;; - https://emacs.stackexchange.com/a/13290/12534
  ;;; - http://stackoverflow.com/a/22863701/3538165
  ;;;
  ;;; See also:
  ;;; - https://emacs.stackexchange.com/a/24800/12534
  ;;; - https://emacs.stackexchange.com/q/27459/12534

  ;; <return> is for windowed Emacs; RET is for terminal Emacs
  (dolist (key '("<return>" "RET"))
    ;; Here we are using an advanced feature of define-key that lets
    ;; us pass an "extended menu item" instead of an interactive
    ;; function. Doing this allows RET to regain its usual
    ;; functionality when the user has not explicitly interacted with
    ;; Company.
    (define-key company-active-map (kbd key)
      `(menu-item nil company-complete
                  :filter ,(lambda (cmd)
                             (when (company-explicit-action-p)
                               cmd)))))
  (define-key company-active-map (kbd "TAB") #'company-complete-selection)
  (define-key company-active-map (kbd "SPC") nil)

  ;; Company appears to override the above keymap based on company-auto-complete-chars.
  ;; Turning it off ensures we have full control.
  (setq company-auto-complete-chars nil)

(define-key company-active-map (kbd "C-n") #'company-select-next)
(define-key company-active-map (kbd "C-p") #'company-select-previous)

#+END_SRC

** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= and =company= for a while I decided to .. use both?
AC is for Lua/LÖVE and Company for the rest.

Each category also has additional settings.

*** C/C++
#+BEGIN_SRC emacs-lisp
(add-hook 'c++-mode-hook 'yas-minor-mode)
(add-hook 'c-mode-hook 'yas-minor-mode)

(use-package flycheck-clang-analyzer
  :ensure t
  :config
  (with-eval-after-load 'flycheck
    (require 'flycheck-clang-analyzer)
    (flycheck-clang-analyzer-setup)))

(with-eval-after-load 'company
  (add-hook 'c++-mode-hook 'company-mode)
  (add-hook 'c-mode-hook 'company-mode))

(use-package company-c-headers
  :ensure t)

(use-package company-irony
  :ensure t
  :config
  (setq company-backends '((company-c-headers
                            company-dabbrev-code
                            company-irony))))

(use-package irony
  :ensure t
  :config
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** Python
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'yas-minor-mode)
(add-hook 'python-mode-hook 'flycheck-mode)

(with-eval-after-load 'company
  (add-hook 'python-mode-hook 'company-mode))

(defun python-mode-company-init ()
  (setq-local company-backends '((company-jedi
                                  company-etags
                                  company-dabbrev-code))))

(use-package company-jedi
  :ensure t
  :config
  (require 'company)
  (add-hook 'python-mode-hook 'python-mode-company-init))

#+END_SRC

**** Elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
:ensure t
:defer t
:init
(setq elpy-rpc-timeout 30)
(setq elpy-rpc-python-command "python3")
(advice-add 'python-mode :before 'elpy-enable)
:config
(progn
  (setq python-shell-interpreter "python3"
        python-shell-interpreter-args "-i")
  (when (require 'flycheck nil t)
    (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
    (add-hook 'elpy-mode-hook 'flycheck-mode))
)
:bind (:map elpy-mode-map
            ("<f6>" . elpy-black-fix-code))
;; :hook
;; (python-mode . 'elpy-enable)
)
#+END_SRC

**** Python shell
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "python3"
      python-shell-interpreter-args "-i")

(with-eval-after-load 'python
  (defun python-shell-completion-native-try ()
    "Return non-nil if can trigger native completion."
    (let ((python-shell-completion-native-enable t)
          (python-shell-completion-native-output-timeout
           python-shell-completion-native-try-output-timeout))
      (python-shell-completion-native-get-completions
       (get-buffer-process (current-buffer))
       nil "_"))))
#+END_SRC

**** Pytest
#+BEGIN_SRC emacs-lisp
(use-package python-pytest
  :ensure t
  :init
  (global-set-key (kbd "C-c y t") 'python-pytest-popup)
  (global-set-key (kbd "C-c y r") 'python-pytest-repeat)
  (global-set-key (kbd "C-c y F") 'python-pytest-file)
  (global-set-key (kbd "C-c y f") 'python-pytest-function)
  )
#+END_SRC

**** Autopep8
#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :hook(elpy-mode . 'py-autopep8-enable-on-save))
#+END_SRC

*** Emacs-lisp
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
(add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
(add-hook 'emacs-lisp-mode-hook 'company-mode)

(use-package slime
  :ensure t
  :config
  (setq inferior-lisp-program "/usr/bin/sbcl")
  (setq slime-contribs '(slime-fancy)))

(use-package slime-company
  :ensure t
  :init
  (require 'company)
  (slime-setup '(slime-fancy slime-company)))
#+END_SRC

*** Bash
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'yas-minor-mode)
(add-hook 'shell-mode-hook 'flycheck-mode)
(add-hook 'shell-mode-hook 'company-mode)

(defun shell-mode-company-init ()
  (setq-local company-backends '((company-shell
                                  company-shell-env
                                  company-etags
                                  company-dabbrev-code))))

(use-package company-shell
  :ensure t
  :config
  (require 'company)
  (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC

*** Web
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  )

(defun setup-tide-mode ()
  (interactive)
  (tide-setup)
  (flycheck-mode +1)
  (smart-semicolon-mode +1)
  (setq flycheck-check-syntax-automatically '(save mode-enabled))
  (eldoc-mode +1)
  (tide-hl-identifier-mode +1)
  ;; company is an optional dependency. You have to
  ;; install it separately via package-install
  ;; `M-x package-install [ret] company`
  (company-mode +1))

 ;; allow support of tsx files
(require 'web-mode)
(add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))
(add-hook 'web-mode-hook
          (lambda ()
            (when (string-equal "tsx" (file-name-extension buffer-file-name))
              (setup-tide-mode))))
;; enable typescript-tslint checker
(flycheck-add-mode 'typescript-tslint 'web-mode)

 ;; aligns annotation to the right hand side
(setq company-tooltip-align-annotations t)

 ;; formats the buffer before saving
(add-hook 'before-save-hook 'tide-format-before-save)

(add-hook 'typescript-mode-hook #'setup-tide-mode)

 ;;lint
(setq tide-format-options '(
:insertSpaceAfterFunctionKeywordForAnonymousFunctions t
:placeOpenBraceOnNewLineForFunctions nil )
)
(setq-default indent-tabs-mode nil)
(setq typescript-indent-level 2)
(setq web-mode-markup-indent-offset 2)
(setq web-mode-css-indent-offset 2)
(setq web-mode-code-indent-offset 2)
(setq web-mode-indent-style 2)
(add-hook 'html-mode-hook
          (lambda()
            (setq sgml-basic-offset 2)
            (setq tab-width 2)
            (setq indent-tabs-mode t)
            (setq web-mode-enable-current-column-highlight t)
            (setq web-mode-enable-current-element-highlight t)))

#+END_SRC

* Code helpers
** Global
*** Fill column indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  )
#+END_SRC
*** Remove trailing whitespace
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
*** Fill region
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 79)
#+END_SRC
*** Line numbering
#+BEGIN_SRC emacs-lisp
(if (fboundp 'display-line-numbers-mode)
    (use-package display-line-numbers
      :ensure nil
      :hook
      (prog-mode . display-line-numbers-mode)
      (org-mode . display-line-numbers-mode)))
#+END_SRC
*** Anzu (query/replace preview)
#+BEGIN_SRC emacs-lisp
;; --------------------------------------
(global-anzu-mode +1)
(global-set-key [remap query-replace] 'anzu-query-replace)
(global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
;; (add-hook 'after-init-hook ;;'global-emojify-mode 1)
#+END_SRC
*** Helm
#+BEGIN_SRC emacs-lisp
;; HELM

;; helm from https://github.com/emacs-helm/helm
(require 'helm)

(require 'helm-config)
(helm-mode 1)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x r b") 'helm-filtered-bookmarks)
(global-set-key (kbd "C-x C-f") 'helm-find-files)


(require 'helm-swoop)

;; Change the keybinds to whatever you like :)
(global-set-key (kbd "M-i") 'helm-swoop)
(global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
(global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)

;; When doing isearch, hand the word over to helm-swoop
(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
;; From helm-swoop to helm-multi-swoop-all
(define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
;; When doing evil-search, hand the word over to helm-swoop
;; (define-key evil-motion-state-map (kbd "M-i") 'helm-swoop-from-evil-search)

;; Instead of helm-multi-swoop-all, you can also use helm-multi-swoop-current-mode
(define-key helm-swoop-map (kbd "M-m") 'helm-multi-swoop-current-mode-from-helm-swoop)

;; Move up and down like isearch
(define-key helm-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-swoop-map (kbd "C-s") 'helm-next-line)
(define-key helm-multi-swoop-map (kbd "C-r") 'helm-previous-line)
(define-key helm-multi-swoop-map (kbd "C-s") 'helm-next-line)

;; Save buffer when helm-multi-swoop-edit complete
(setq helm-multi-swoop-edit-save t)

;; If this value is t, split window inside the current window
(setq helm-swoop-split-with-multiple-windows nil)

;; Split direcion. 'split-window-vertically or 'split-window-horizontally
(setq helm-swoop-split-direction 'split-window-horizontally)

;; If nil, you can slightly boost invoke speed in exchange for text color
(setq helm-swoop-speed-or-color nil)

;; ;; Go to the opposite side of line from the end or beginning of line
(setq helm-swoop-move-to-line-cycle t)

;; Optional face for line numbers
;; Face name is `helm-swoop-line-number-face`
(setq helm-swoop-use-line-number-face t)

;; If you prefer fuzzy matching
(setq helm-swoop-use-fuzzy-match t)



#+END_SRC
*** Neotree
#+BEGIN_SRC emacs-lisp
(global-set-key [f8] 'neotree-toggle)
#+END_SRC
*** Colorize color names in buffers
#+BEGIN_SRC emacs-lisp
(require 'rainbow-mode)
(add-hook 'prog-mode-hook 'rainbow-mode)
#+END_SRC

*** Sphinx-doc
#+BEGIN_SRC emacs-lisp
(use-package sphinx-doc)
(add-hook 'prog-mode-hook 'sphinx-doc-mode)
#+END_SRC
*** TAGS
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook
          (lambda ()
            (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
              (ggtags-mode 1))))
#+END_SRC
** PHP
*** Indent
#+BEGIN_SRC emacs-lisp
(add-hook 'php-mode-hook '
	  (lambda () (setq c-basic-offset 2)))
#+END_SRC
** C++ CONFIGURATION
*** Indent
#+BEGIN_SRC emacs-lisp
;; --------------------------------------
(c-add-style "my-style"
'("stroustrup"
(indent-tabs-mode . nil)        ; use spaces rather than tabs
(c-basic-offset . 2)            ; indent by four spaces
(c-offsets-alist . ((inline-open . 0)  ; custom indentation rules
(brace-list-open . 0)
(statement-case-open . +)))))

; use my-style defined above
(defun my-c++-mode-hook ()
(c-set-style "my-style")
(auto-fill-mode)
(c-toggle-auto-hungry-state 1))

(add-hook 'c++-mode-hook 'my-c++-mode-hook)
#+END_SRC emacs-lisp

** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC
* Git integration
Countless are the times where I opened ansi-term to use =git= on something.
These times are also something that I'd prefer stay in the past, since =magit= is
great. It's easy and intuitive to use, shows its options at a keypress and much more.
** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :config
  (setq magit-push-always-verify nil)
  (setq git-commit-summary-max-length 50)
  :bind
  ("<f5>" . magit-status)
  ("C-<f5>" . magit-log-all)
  )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package magit-gitflow
  :hook (magit-mode-hook . turn-on-magit-gitflow)
)
#+END_SRC

** Git gutter
#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure t
  :diminish git-gutter-mode
  :config (global-git-gutter-mode))
  #+END_SRC
* Remote editing
I have no need to directly edit files over SSH, but what I do need is a way to edit files as root.
Opening up nano in a terminal as root to play around with grubs default settings is a no-no, this solves that.
** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
  :ensure t
  :bind
  ("C-c s e" . sudo-edit))
#+END_SRC
* Org
One of the absolute greatest features of emacs is called "org-mode".
This very file has been written in org-mode, a lot of other configurations are written in org-mode, same goes for
academic papers, presentations, schedules, blogposts and guides.
Org-mode is one of the most complex things ever, lets make it a bit more usable with some basic configuration.

Those are all rather self-explanatory.

** Common settings

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-confirm-babel-evaluate nil)
(setq org-export-with-smart-quotes t)
(setq org-src-window-setup 'current-window)
(setq org-catch-invisible-edits 'show-and-error)
(setq org-cycle-separator-lines 0)
(add-hook 'org-mode-hook 'org-indent-mode)

#+END_SRC

** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
(use-package htmlize
  :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
	  '(lambda ()
	     (visual-line-mode 1)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!

*** latex
#+BEGIN_SRC emacs-lisp
(when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
  (require 'xdvi-search))
#+END_SRC

** Jump to todo list
#+BEGIN_SRC emacs-lisp
(defun todo-visit ()
  (interactive)
  (find-file "~/notes.org"))
(global-set-key (kbd "C-c t") 'todo-visit)
#+END_SRC
** Todo keywords
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords '((sequence "TODO" "WIP" "BLOCKED" "DONE")))
#+END_SRC

* Diminishing modes
Your modeline is sacred, and if you have a lot of modes enabled, as you will if you use this config,
you might end up with a lot of clutter there, the package =diminish= disables modes on the mode line but keeps
them running, it just prevents them from showing up and taking up space.

*THIS WILL BE REMOVED SOON AS USE-PACKAGE HAS THE FUNCTIONALITY BUILT IN*

Edit this list as you see fit!
#+BEGIN_SRC emacs-lisp
(use-package diminish
  :ensure t
  :init
  (diminish 'which-key-mode)
  (diminish 'linum-relative-mode)
  (diminish 'hungry-delete-mode)
  (diminish 'visual-line-mode)
  (diminish 'subword-mode)
  (diminish 'beacon-mode)
  (diminish 'irony-mode)
  (diminish 'page-break-lines-mode)
  (diminish 'auto-revert-mode)
  (diminish 'rainbow-delimiters-mode)
  (diminish 'rainbow-mode)
  (diminish 'yas-minor-mode)
  (diminish 'flycheck-mode)
  (diminish 'helm-mode))
#+END_SRC

* Copy/Paste from/to X clipboard

Lets M-c and M-v to copy and paste from X. To do that, we first need to define
the following functions, found on https://github.com/dpsxp/emacs-setup

#+BEGIN_SRC emacs-lisp
(defun copy-to-clipboard ()
  (interactive)
  (if (display-graphic-p)
      (progn
        (message "Yanked region to x-clipboard!")
        (call-interactively 'clipboard-kill-ring-save)
        )
    (if (region-active-p)
        (progn
          (shell-command-on-region (region-beginning) (region-end) "xsel -i -b")
          (message "Yanked region to clipboard!")
          (deactivate-mark))
      (message "No region active; can't yank to clipboard!"))))
(setq x-select-enable-clipboard nil)
(defun paste-from-clipboard ()
  (interactive)
  (setq x-select-enable-clipboard t)
  (yank)
  (setq x-select-enable-clipboard nil))

(global-set-key (kbd "M-c") 'copy-to-clipboard)
(global-set-key (kbd "M-v") 'paste-from-clipboard)
#+END_SRC

* Fill column indicator
#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :diminish ""
  )
#+END_SRC

* White Spaces

For now, I stick to 2-spaces over tabs when I can. But there are some folks ou*t
there who do not think the way I do and I want to be able to work with them. The
dtrt-indent_ package provides a way for emacs to guess which indentation rules
to follow based on the current file.

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(use-package dtrt-indent
  :ensure t
  :diminish ""
  :config
  (progn
    (add-hook 'prog-mode-hook (lambda ()  (dtrt-indent-mode 1)))))
#+END_SRC

* Dumb-jump

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure t
  :init
  (dumb-jump-mode)
  :bind (("M-g o" . dumb-jump-go-other-window)
         ("M-g j" . dumb-jump-go)
         ("M-g x" . dumb-jump-go-prefer-external)
         ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config (setq dumb-jump-selector 'helm)
  )
#+END_SRC
* Debug helpers
** Package signature failed
#+BEGIN_SRC shell-script
gpg --homedir $HOME/.emacs.d/elpa/gnupg  --keyserver keyserver.ubuntu.com --recv-keys 066DAFCB81E42C40
#+END_SRC

* Keychord
#+BEGIN_SRC emacs-lisp
(use-package key-chord
  :ensure t
  :config
  (key-chord-define-global "JJ" 'avy-goto-word-1)
  (key-chord-define-global "JL" 'avy-goto-line)
  (key-chord-define-global "JK" 'avy-goto-char)
  (key-chord-define-global "JJ" 'crux-switch-to-previous-buffer)
  (key-chord-define-global "XX" 'execute-extended-command)
  (key-chord-define-global "YY" 'browse-kill-ring)
  (key-chord-define-global "VV" 'helm-M-x)
  (key-chord-define-global "FF" 'helm-find-files)
  (key-chord-define-global "PP" 'projectile-switch-project)
  (key-chord-define-global "PF" 'projectile-find-file)
  (key-chord-define-global "PS" 'projectile-ag)
  (key-chord-define-global "PR" 'projectile-replace)

  (key-chord-mode +1))
#+END_SRC

* Restclient
#+BEGIN_SRC emacs-lisp
(use-package restclient
  :ensure t
  :defer t
)
#+END_SRC
* Pretty mode
#+BEGIN_SRC emacs-lisp
(use-package pretty-mode
  :ensure t
  :config
  (global-pretty-mode t)
)
#+END_SRC
* Log4j
#+BEGIN_SRC emacs-lisp
(use-package log4j-mode
  :ensure t
  :defer t
)
#+END_SRC
* epoch-view
#+BEGIN_SRC emacs-lisp
(use-package epoch-view
  :ensure t
  :defer t
)
#+END_SRC
* magic-theme
#+BEGIN_SRC emacs-lisp
(use-package theme-magic
  :ensure t
  :defer t
)
#+END_SRC
* Github review
Please refer to package documentation to configure Github Enterprise

#+BEGIN_SRC emacs-lisp
(use-package github-review
  :ensure t
  :defer t
)
#+END_SRC
* Forge
#+BEGIN_SRC emacs-lisp
(use-package forge
  :ensure t
  :defer t
)
#+END_SRC
